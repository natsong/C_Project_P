对于以下代码段输出结果为什么？为什么会如此？

#include <stdio.h>

int main()
{
  char a=-1;
  usigned char b=-1;
  printf("a=%d,b=%d\n",a,b);
  return 0;
}

//代码结果：
a=-1,b=255

问题分析：
1）
对于char a,-1 对应的原码、反码、补码分别为：
原：10000000000000000000000000000001
反：11111111111111111111111111111110 （原码符号位不变，数值位按位取反）
补：11111111111111111111111111111111 （反码+1，若溢出则直接抛弃最高位）

存储时由于存储在char 变量大小的内存空间中，因此只能存储低位一个字节：11111111
输出时候需要提升：
提升方案：
对于 有符号正整数 提升只需要左边添0
对于 无符号整数或者有符号负整数 提升 只需要左边添1

由于作为%d输出，意味着要提升至32位，且输出的是原码

char类型表示有符号类型即 11111111 表示负数，因此左添1提升后数据为11111111111111111111111111111111

输出函数发现最高位为1故认为是负数补码，因而求出其原码：10000000000000000000000000000001

输出结果为-1

2）

对于unsigned char b,-1对应的 原码、反码、补码分别为
原：10000000000000000000000000000001
反：11111111111111111111111111111110 （原码符号位不变，数值位按位取反）
补：11111111111111111111111111111111 （反码+1，若溢出则直接抛弃最高位）
存储时仍只能存储char变量大小的内存空间，因此只存低位一个字节： 11111111
按%d 输出时 需要补齐，而对unsigned char 无符号变量，只需要左添0 提升后数据为：00000000000000000000000011111111
输出函数发现其最高位为0 ，认为其为正整数，因此其原码为：00000000000000000000000011111111

输出结果为255



